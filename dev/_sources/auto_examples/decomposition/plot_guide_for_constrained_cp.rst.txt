
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/decomposition/plot_guide_for_constrained_cp.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_decomposition_plot_guide_for_constrained_cp.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_decomposition_plot_guide_for_constrained_cp.py:


Constrained CP decomposition in Tensorly >=0.7
===============================================
On this page, you will find examples showing how to use constrained CP/Parafac.

.. GENERATED FROM PYTHON SOURCE LINES 8-67

Introduction
-----------------------
Since version 0.7, Tensorly includes constrained CP decomposition which penalizes or
constrains factors as chosen by the user. The proposed implementation of constrained CP uses the 
Alternating Optimization Alternating Direction Method of Multipliers (AO-ADMM) algorithm from [1] which
solves alternatively convex optimization problem using primal-dual optimization. In constrained CP
decomposition, an auxilliary factor is introduced which is constrained or regularized using an operator called the 
proximal operator. The proximal operator may therefore change according to the selected constraint or penalization.

Tensorly provides several constraints and their corresponding proximal operators, each can apply to one or all factors in the CP decomposition:

1. Non-negativity
       * `non_negative` in signature
       * Prevents negative values in CP factors.
2. L1 regularization
       * `l1_reg` in signature
       * Adds a L1 regularization term on the CP factors to the CP cost function, this promotes sparsity in the CP factors. The user chooses the regularization amount.
3. L2 regularization
       * `l2_reg` in signature
       * Adds a L2 regularization term on the CP factors to the CP cost function. The user chooses the regularization amount.
4. L2 square regularization
       * `l2_square_reg` in signature
       * Adds a L2 regularization term on the CP factors to the CP cost function. The user chooses the regularization amount.
5. Unimodality
       * `unimodality` in signature
       * This constraint acts columnwise on the factors
       * Impose that each column of the factors is unimodal (there is only one local maximum, like a Gaussian).
6. Simplex
       * `simplex` in signature
       * This constraint acts columnwise on the factors
       * Impose that each column of the factors lives on the simplex or user-defined radius (entries are nonnegative and sum to a user-defined positive parameter columnwise).
7. Normalization
       * `normalize` in signature
       * Impose that the largest absolute value in the factors elementwise is 1.
8. Normalized sparsity
       * `normalized_sparsity` in signature
       * This constraint acts columnwise on the factors
       * Impose that the columns of factors are both normalized with the L2 norm, and k-sparse (at most k-nonzeros per column) with k user-defined.
9. Soft sparsity
       * `soft_sparsity` in signature
       * This constraint acts columnwise on the factors
       * Impose that the columns of factors have L1 norm bounded by a user-defined threshold.
10. Smoothness
       * `smoothness` in signature
       * This constraint acts columnwise on the factors
       * Favor smoothness in factors columns by penalizing the L2 norm of finite differences. The user chooses the regularization amount. The proximal operator in fact solves a banded system.
11. Monotonicity
       * `monotonicity` in signature
       * This constraint acts columnwise on the factors
       * Impose that the factors are either always increasing or decreasing (user-specified) columnwise. This is based on isotonic regression.
12. Hard sparsity
       * `hard_sparsity` in signature
       * This constraint acts columnwise on the factors
       * Impose that each column of the factors has at most k nonzero entries (k is user-defined).

While some of these constraints (2, 3, 4, 6, 8, 9, 12) require a scalar
input as its parameter or regularizer, boolean input could be enough
for other constraints (1, 5, 7, 10, 11). Selection of one of these
constraints for all mode (or factors) or using different constraints for different modes are both supported.

.. GENERATED FROM PYTHON SOURCE LINES 67-79

.. code-block:: default


    import numpy as np
    import tensorly as tl
    from tensorly.decomposition import constrained_parafac
    import matplotlib.pyplot as plt

    np.set_printoptions(precision=2)

    # tensor generation
    tensor = tl.tensor(np.random.rand(6, 8, 10))
    rank = 3








.. GENERATED FROM PYTHON SOURCE LINES 80-88

Using one constraint for all modes
--------------------------------------------
Constraints are inputs of the constrained_parafac function, which itself uses the
``tensorly.tenalg.proximal.validate_constraints`` function in order to process the input
of the user. If a user wants to use the same constraint for all modes, an
input (bool or a scalar value or list of scalar values) should be given to this constraint.
Assume, one wants to use unimodality constraint for all modes. Since it does not require
any scalar input, unimodality can be imposed by writing `True` for `unimodality`:

.. GENERATED FROM PYTHON SOURCE LINES 88-91

.. code-block:: default


    _, factors = constrained_parafac(tensor, rank=rank, unimodality=True)








.. GENERATED FROM PYTHON SOURCE LINES 92-93

This constraint imposes that each column of all the factors in the CP decomposition are unimodal:

.. GENERATED FROM PYTHON SOURCE LINES 93-99

.. code-block:: default


    fig = plt.figure()
    for i in range(rank):
        plt.plot(factors[0][:, i])
        plt.legend(['1. column', '2. column', '3. column'], loc='upper left')




.. image-sg:: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_001.png
   :alt: plot guide for constrained cp
   :srcset: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 100-101

Constraints requiring a scalar input can be used similarly as follows:

.. GENERATED FROM PYTHON SOURCE LINES 101-103

.. code-block:: default

    _, factors = constrained_parafac(tensor, rank=rank, l1_reg=0.05)








.. GENERATED FROM PYTHON SOURCE LINES 104-105

The same regularization coefficient l1_reg is used for all the modes. Here the l1 penalization induces sparsity given that the regularization coefficient is large enough.

.. GENERATED FROM PYTHON SOURCE LINES 105-113

.. code-block:: default

    fig = plt.figure()
    plt.title('Histogram of 1. factor')
    _, _, _ = plt.hist(factors[0].flatten())

    fig = plt.figure()
    plt.title('Histogram of 2. factor')
    _, _, _ = plt.hist(factors[1].flatten())




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_002.png
         :alt: Histogram of 1. factor
         :srcset: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_003.png
         :alt: Histogram of 2. factor
         :srcset: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_003.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 114-118

Using one constraint for some modes
--------------------------------------------
As a second option, constraint can be used for only a few selected modes by using
a python dictionary:

.. GENERATED FROM PYTHON SOURCE LINES 118-123

.. code-block:: default


    _, factors = constrained_parafac(tensor, rank=rank, non_negative={0: True, 2: True})
    print("1. factor\n", factors[0])
    print("2. factor\n", factors[1])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1. factor
     [[5.47 1.5  1.34]
     [4.95 1.37 1.62]
     [3.91 0.37 0.19]
     [4.66 0.42 0.14]
     [5.79 2.77 2.91]
     [6.14 3.2  3.22]]
    2. factor
     [[ 0.27  0.22 -0.24]
     [ 0.41 -0.52  0.18]
     [ 0.25  0.93 -0.96]
     [ 0.45 -0.39  0.05]
     [ 0.38 -0.36  0.11]
     [ 0.36 -0.15 -0.06]
     [ 0.33 -0.21  0.02]
     [ 0.4  -0.96  0.71]]




.. GENERATED FROM PYTHON SOURCE LINES 124-125

Since only the first and last factors are chosen, entries on the second mode factor could be negative.

.. GENERATED FROM PYTHON SOURCE LINES 128-132

Using a constraint with the different scalar inputs for each mode
---------------------------------------------------------
One may prefer different scalar value for each mode. It is possible by
using a list structure:

.. GENERATED FROM PYTHON SOURCE LINES 132-147

.. code-block:: default


    _, factors = constrained_parafac(tensor, rank=rank, l1_reg=[0.01, 0.02, 0.03])

    fig = plt.figure()
    plt.title('Histogram of 1. factor')
    _, _, _ = plt.hist(factors[0].flatten())

    fig = plt.figure()
    plt.title('Histogram of 2. factor')
    _, _, _ = plt.hist(factors[1].flatten())

    fig = plt.figure()
    plt.title('Histogram of 3. factor')
    _, _, _ = plt.hist(factors[2].flatten())




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_004.png
         :alt: Histogram of 1. factor
         :srcset: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_005.png
         :alt: Histogram of 2. factor
         :srcset: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_006.png
         :alt: Histogram of 3. factor
         :srcset: /auto_examples/decomposition/images/sphx_glr_plot_guide_for_constrained_cp_006.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 148-152

Using different constraints for each mode
--------------------------------------------
To use different constraint for different modes, the dictionary structure
should be preferred:

.. GENERATED FROM PYTHON SOURCE LINES 152-156

.. code-block:: default


    _, factors = constrained_parafac(tensor, rank=rank, non_negative={1:True}, l1_reg={0: 0.01},
                                     l2_square_reg={2: 0.01})








.. GENERATED FROM PYTHON SOURCE LINES 157-159

In the dictionary, `key` is the selected mode and `value` is a scalar value or
only `True` depending on the selected constraint.

.. GENERATED FROM PYTHON SOURCE LINES 159-164

.. code-block:: default


    print("1. factor\n", factors[0])
    print("2. factor\n", factors[1])
    print("3. factor\n", factors[2])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1. factor
     [[ 19.12  10.43  10.82]
     [ 18.51 -14.09 -24.45]
     [ 16.04 -12.17  -4.57]
     [ 20.08  14.79 -16.63]
     [ 17.61   2.03   3.27]
     [ 18.41  11.56  -8.17]]
    2. factor
     [[0.36 1.16 0.39]
     [0.37 0.   0.  ]
     [0.37 0.   0.07]
     [0.43 0.3  0.89]
     [0.38 0.   0.57]
     [0.4  0.   1.06]
     [0.34 0.85 0.  ]
     [0.36 0.19 0.21]]
    3. factor
     [[ 0.07 -0.01  0.  ]
     [ 0.07  0.02 -0.01]
     [ 0.07  0.01 -0.  ]
     [ 0.07  0.01 -0.  ]
     [ 0.06  0.01 -0.02]
     [ 0.07 -0.02 -0.  ]
     [ 0.08 -0.03  0.01]
     [ 0.08 -0.01  0.02]
     [ 0.08  0.    0.02]
     [ 0.07  0.01  0.02]]




.. GENERATED FROM PYTHON SOURCE LINES 165-168

Thus, first factor will be non-negative, second factor will be regularized
by :math:`0.01` with :math:`l_1` and last factor will be regularized by
:math:`0.01` with :math:`l_2^2`.

.. GENERATED FROM PYTHON SOURCE LINES 170-179

References
----------

[1] Huang, Kejun, Nicholas D. Sidiropoulos, and Athanasios P. Liavas.
"A flexible and efficient algorithmic framework for constrained
matrix and tensor factorization."
IEEE Transactions on Signal Processing 64.19 (2016): 5052-5065.
`(Online version)
<https://ieeexplore.ieee.org/document/7484753>`_


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  6.635 seconds)


.. _sphx_glr_download_auto_examples_decomposition_plot_guide_for_constrained_cp.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_guide_for_constrained_cp.py <plot_guide_for_constrained_cp.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_guide_for_constrained_cp.ipynb <plot_guide_for_constrained_cp.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
